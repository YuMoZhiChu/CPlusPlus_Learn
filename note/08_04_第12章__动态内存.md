# 动态内存

内存分三类
- 静态内存：保存局部 static 对象，类 static 数据成员，以及定义在任何函数之外的变量
- 栈内存： 保存定义在函数内的 非static对象。
- 静态内存和栈内存，都由编译器自动创建和销毁。
- 栈对象，在定义的程序块，运行时，才存在
- staic 对象在使用之前分配，在程序结束时销毁

- **堆**，程序用堆来存储**动态分配**的对象

## 动态内存与智能指针

### shared_ptr类
智能指针也是模板，需要给括号内的类型。
```
shared_ptr<string> p1;
shared_ptr<list<int>> p2; 
```
- 可以指向 string，int的list，的指正
- 默认初始化的智能指针中，保存一个**空指针**

s_p 和 u_p 都支持的操作 | 解析
------------- | ------------- 
```shared_ptr<T> sp``` |  空智能指针，可以指向类型为 T 的对象
```unique_ptr<T> up``` |  同上
```p``` |  将 p 用作一个条件判断，若 p 指向一个对象，就是 true
```*p``` |  解引用 p，获得它指向的对象
```p->mem``` |  等价于 ```(*p).mem```
```p.get()``` |  返回 p 中保存的指针。
```swap(p, q)``` |  交换 p 和 q 中的指针
```p.swaq(q)``` |  

s_p 独有的操作 | 解析
------------- | ------------- 
```make_shared<T>(args)``` |  返回一个 s_p，指向一个动态分配的类型为T的对象，使用 args 初始化它
```shared_ptr<T>p(q)``` | p 是 q 的拷贝，这种做法会增加 q 的计数器。还需要确保，q能转换为 T*
```p=q``` |  p 和 q 都是 s_p，这么做，q 的计数器会递增，p 的计数器会递减，如果变成 0，会释放内存
```p.unique()``` | 查询  
```p.use_count()``` |  查询与 p 共享对象的智能指针的数量，可能会很慢


#### make_shared
最安全的分配和使用动态内存的方法，该函数返回一个 s_p。在头文件```memory```中定义
```c++
shared_ptr<int> p3 = make_shared<int>(42); // 一个指向 int 的 sp
shared_ptr<string> p3 = make_shared<int>(10,"9"); // 一个指向 string 的 sp
shared_ptr<int> p3 = make_shared<int>(); // 一个指向 int 的 sp，值初始化，0
```
- 该函数传入参数，很像```emplace```，传入的是初始化的参数，所以 string 也可以传入```10, '9'```来初始化

#### s_p 的拷贝和赋值
```c++
auto p = make_shared<int>(42); // p指向的对象只有p一个引用者
auto q(p); // q这个时候，跟p一样，该对象有两个引用者
```
我们可以认为，每个 sp 都有一个关联的计数器，被称为**引用计数**。
- 无论何时拷贝一个 sp，计数器都会增加，比如：
- - 用一个 sp 初始化另一个 sp
- - 讲他作为一个参数，传递给一个函数
- - 作为一个函数的返回值
- 我们给 sp 赋予一个新值，或者 sp被销毁（比如局部的 sp 离开作用域），计数器就会递减

一旦 sp 的计数器变为 0，那么它会自动释放自己管理的对象。

#### sp 自动销毁锁管理的对象
sp 是通过特殊的成员函数 **析构函数** 来完成销毁工作的。在引用计数变为0时：
- - 析构函数，销毁对象
- - 释放占用的内存

```c++
shared_ptr<Foo> factory(T arg)
{
	// 返回一个 sp，让这个 sp 管理内存
	return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
	auto p = factory(arg);
	// 使用 p
}// p 离开了作用域，他指向的内存就被释放了

shared_ptr<Foo> use_factory2(T arg)
{
	auto p = factory(arg);
	// 使用 p
	return p;
}// 因为函数调用，返回了一个 p 的拷贝，所以不会被释放掉
```
- sp的自动管理内存
- 如果将 sp 存入一个容器中，记得 erase 删除的元素，来保证释放，元素中，对应的 sp，指向的内存

#### 使用动态生存期的资源
使用动态内存，出于三种原因
- 不知道需要多少对象
- 不知道对象的准确类型
- 需要在多个对象间，共享数据。

下面介绍一种，第3个情况的写法。
```c++
#include <vector>
#include <string>
#include <initializer_list>
#include <memory>
#include <exception>

using std::vector;
using std::string;

class StrBlob {
public:
	// 注意，这个是一个 正整数
    using size_type = vector<string>::size_type;

	// 使用一个 sp，StrBlob类，能够共享底层的 vector<string> 数据
    StrBlob() : data(std::make_shared<vector<string>>()) {}
	// C++11 标准，使用 {} 来初始化 vector
    StrBlob(std::initializer_list<string> il)
        : data(std::make_shared<vector<string>>(il))
    {
    }

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back(const string& t) { data->push_back(t); }
    void pop_back()
    {
        check(0, "pop_back on empty StrBlob");
        data->pop_back();
    }

    std::string& front()
    {
        check(0, "front on empty StrBlob");
        return data->front();
    }

    std::string& back()
    {
        check(0, "back on empty StrBlob");
        return data->back();
    }

    const std::string& front() const
    {
        check(0, "front on empty StrBlob");
        return data->front();
    }
    const std::string& back() const
    {
        check(0, "back on empty StrBlob");
        return data->back();
    }

private:
    void check(size_type i, const string& msg) const
    {
        if (i >= data->size()) throw std::out_of_range(msg);
    }

private:
    std::shared_ptr<vector<string>> data;
};
```
- 为什么没有 const 版本的 push_back 和 pop_back
- - 因为虽然 const，不会改变 类的成员数据，但是我们通过指针进行了修改，是自欺欺人的做法
- ```StrBlob(std::initializer_list<string> il)``` 用 explicit  的好处和坏处
- - 使用 explicit， 用起来会很方便
- - 不使用，不会在意料不到的地方自动转换，结构清晰

### 直接管理内存
C++ 给出了两个运算符来直接管理内存，他们是 **new** 和 **delete**

```c++
string *ps1 = new string; // 默认初始化为空 string
string *ps2 = new string(); // 值初始化为空 string
int *pi1 = new int; // 默认初始化，*pil的值未定义
int *pi2 = new int(); // 值初始化为 0
```
- 在这里，内置类型是未定义的，所以我们尽可能使用初始化。
```c++
auto p1 = new auto(obj); // 与obj类型相同的对象
auto p2 = new auto{a, b, c}; //  错误，因为括号中只能有当个初始化器
```
- 在这里，只有括号中，有单一初始化器，才能用 auto 去判断类型

#### 动态分配的const对象
```
// 分配并初始化一个 const int
const int *pci = new const int(1024);
// 分配并默认初始化一个 const 的 空string 
const string *pcs = new const string;
```
- 动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的，比如这里的string，可以隐式初始化。
- 这里返回的，是 指向const 的指针

#### 内存耗尽
```c++
int *p1 = new int; // 如果分配失败，new 会抛出 std::bad_alloc
int *p2 = new (nothrow) int; // 如果分配失败，new 返回一个空指针
```
- 我们可以通过修改分配时的语句，来确定是否抛出异常（默认抛出

#### 指针值和delete
使用 **delete**  来执行两个动作
- 销毁给定的指针指向的对象
- 释放相应的内存

```c++
int i, *pil = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // 错误，i不是一个指针
delete pil; // 未定义，pil 指向的是一个局部变量，不是动态内存
delete pd; // 正确
delete pd2; // 未定义 pd 已经被释放了
delete pi2; // 正确，释放一个空指针是没有错的
```
- 指针的使用方法
- const 对象的值，也是可以销毁的，所以可以 delete 一个指向const的动态内存的指针

- 动态内存，如果不手动释放的话，会**一直存在**，所以会有内存泄露


