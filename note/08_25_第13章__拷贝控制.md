# 拷贝，赋值，销毁

## 拷贝构造函数

### 定义
```c++
class Foo {
public:
	Foo(); // 默认构造函数
	Foo(const Foo&); // 拷贝构造函数
};
```
- 拷贝构造第一个参数，必须是**引用类型**
- 拷贝构造函数，一般不加`explicit`，因为我们平常默认要支持隐式构造

### 合成拷贝构造函数

- 即使定义了其他的构造函数，编译器**还是会**合成一个拷贝构造函数
- 合成的拷贝构造函数做什么？
- - 参数的成员逐个拷贝到正在创建的对象中。编译器将每个`非static`成员拷贝。
- - 内置成员：直接拷贝
- - 类类型：调用它的拷贝构造函数
- - 数组：逐个拷贝

### 拷贝初始化

先看几个例子

```c++
 // 直接初始化
string dots(10,'.');
string s(dots);

// 拷贝初始化
string s2=dots;
string nullbook = "99-009-00";
string nlines = string(100,'9');
```
- 直接初始化 ： 使用普通的函数匹配，来选择提供参数最匹配的构造函数。
- 拷贝初始化 ： 将右侧运算对象**拷贝到**正在创建的对象中，如果需要，会进行类型转换

拷贝初始化发生的情况
- 用`=`进行**定义**变量
- 将一个对象，作为实参，传递给一个**非引用类型**的形参（非引用的参数传递
- 用**花括号列表初始化**一个数组中的元素，或者一个聚合类的成员

*注意到，这里传承会导致拷贝初始化，所以拷贝初始化函数必须是引用，否则会无限循环下去*

标准库中，`insert`和`push`都是**拷贝初始化**，`emplace`都是**直接初始化**

### 参数和返回值

- 当函数返回一个**非引用**时，返回值会发生一次拷贝构造（**理解成，对返回值进行一次拷贝构造，因为即使不做赋值，也会有构造函数的调用**

### 拷贝初始化的限制

```c++
vector<int> v1(10);// OK,构造函数的调用
vector<int> v2 = 10;// NO,这个构造函数是 explicit 的，必须显示调用
void f(vector<int>);// 这是一个传参，会进行拷贝初始化
f(10);// NO,一样，调用不了 explicit 的初始化
f(vector<int>(10));// OK,这个初始化就很对
```
- 一些初始化函数，可能会非常简洁，比如这里的`vector`用一个`int`来初始化大小，这种初始化函数要用`explicit`声明，不然，在这里用拷贝初始化，代码会非常难懂

### 练习点

指针变量的拷贝
```c++
class HasPtr {
public:
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0)
    {
    }
	// 指针指向一块新的内存，并拷贝内容，而不是单纯的复制指针指向的地址
    HasPtr(const HasPtr& hp) : ps(new std::string(*hp.ps)), i(hp.i) {}
private:
    std::string* ps;
    int i;
};
```

## 拷贝赋值运算符

### 重载运算符

```c++
class numbered {
public:
	// 为什么前后都是引用
	// 因为传入，和返回，如果不是引用，我们都会发生多一次的构造，这样很不利
	numbered& operator=(const numbered &rhs)
	{
		mysn = rhs.mysn;
		cout << "调用了拷贝赋值函数" << endl;
		return *this;
	};
	int mysn;
};
```

### 合成拷贝运算符

- 如果类没有定义，那么编译器会为其**合成拷贝赋值运算符**

### 练习点

指针的拷贝赋值函数

```c++
#include <string>

class HasPtr {
public:
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0)
    {
    }
    HasPtr(const HasPtr& hp) : ps(new std::string(*hp.ps)), i(hp.i) {}
	// 这里不是简单的拷贝指针指向地址
	// 是开一块新的内存，并拷贝初始化，并指向它
    HasPtr& operator=(const HasPtr& hp)
    {
        std::string* new_ps = new std::string(*hp.ps);
        delete ps;
        ps = new_ps;
        i = hp.i;
        return *this;
    }

private:
    std::string* ps;
    int i;
};
```

## 析构函数

- 析构函数不接受参数，不能被重载，一个类只有一个

### 析构函数完成什么工作

- 执行函数体
- 按照成员初始化顺序的**逆序**销毁成员

- 内置指针不会`delete`，智能指针是类，所以会调用自己的析构函数

### 什么时候会调用析构函数

- 变量在离开作用域
- 对象实例被销毁，它的成员就跟着销毁
- 容器销毁（无论是标准库还是数组），元素被销毁
- 动态分配的对象，执行`delete`时
- 对于**临时对象**，当创建它的完整表达式结束时
- 指针或引用离开作用域是，析构不会执行。

### 合成析构函数

- 同理，编译器会在未定义时，合成析构函数
- 成员的销毁，并不是在析构函数体内发生的，而是在隐含的析构阶段中销毁的

### 练习点

- 带指针的类的析构
```c++
#include <string>

class HasPtr {
public:
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0)
    {
    }
    HasPtr(const HasPtr& hp) : ps(new std::string(*hp.ps)), i(hp.i) {}
    HasPtr& operator=(const HasPtr& hp)
    {
        std::string* new_ps = new std::string(*hp.ps);
        delete ps;
        ps = new_ps;
        i = hp.i;
        return *this;
    }
    ~HasPtr() { delete ps; }
private:
    std::string* ps;
    int i;
};
```



## 三/五法则

这里指的是 3个控制的拷贝操作
- 拷贝构造函数
- 拷贝赋值运算符
- 析构函数

新标准加了两个
- 移动构造函数
- 移动赋值运算符

如何判断哪些函数是需要重写的？

### 需要析构函数的类也需要拷贝和赋值操作

比如：
```c++
#include <string>

class HasPtr {
public:
    HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0)
    {
    }
    ~HasPtr() { delete ps; }
private:
    std::string* ps;
    int i;
};

```
- 该实例如果不定义`拷贝构造函数`和`拷贝赋值运算符`，那么就可能出现重复销毁的内存错误

### 如果需要拷贝操作，那就也需要赋值操作，反之亦然

## 使用=default

- 显示的声明使用编译器的合成函数
- 内联的
- 只能对编译器可以合成的默认函数后面加

## 阻止拷贝

比如，`iostream`要阻止拷贝，防止多个对象写入或读相同的IO

### 定义删除的函数

```c++
struct Nocopy {
	Nocopy() = default;
	// 阻止拷贝和赋值
	Nocopy(const Nocopy&) = delete;
	Nocopy &operator=(const Nocopy&) = delete;
};
```
-`=delete`必须出现在第一次声明时
-可以对任何函数使用`=delete`，比如继承类，删除一些函数

### 析构函数不能删除

其实也可以删除，但是不能定义这种变量，或者不能删除指向这类型变量的指针（这样还有什么用？

### 合成的拷贝控制成员可能是删除的

这里要注意一点，在代码中，有可能会把这些控制成员函数，进行删除或者隐藏（使用`private`

- 对于具有引用成员，或者无法默认构造的const成员的类，编译器无法合成默认构造函数（因为这两个必须赋予初值，但是编译器不知道
- 一个类有const成员，就不能使用拷贝赋值运算符，因为对一个const赋值，是做不到的
- 如果有引用成员，做赋值，那么改变的是引用指向的对象，而不是用这个引用，去重新引用，传入的对应参数对象，所以，一般来说，有引用成员的类，合成拷贝赋值运算符是被定义删除的

### private 拷贝控制

这种方法是在新标准之前的，在`private`中，声明但不定义拷贝控制函数