# 顺序容器初探

## 概述

c++提供了一堆方便操作和使用的容器，这里专门是介绍顺序容器

标准库的顺序容器中，都提供了快速访问元素的能力

他们的实现方式和功能不同，对应的性能也不同，主要是两点
- 向容器添加，删除元素的代价
- 随机访问某个位置元素的代价

在这里是所有类型容器的概述

类  | 概述 
------------- | ------------- 
vector | 可变大小数组。支持快速**随机**访问，在**尾部**删除或插入很快，其他很慢
deque  | 双端队列。支持快速**随机**访问，在**头尾**删除或插入很快，其他很慢
list  | 双向链表。只支持双向**顺序**访问，在**任何**地方删除或插入都很快
forward_list  | 单向链表。只支持单向**顺序**访问，在**任何**地方删除或插入都很快
array | 固定大小数组。支持快速**随机**访问，**不能**添加或删除
string | 与 **vector** 相似，但专门用于保存**字符**

特殊的点：
- array 是固定大小
- vector 和 string 都是将元素保存在连续空间中，主要有2点问题
- - 非尾位置插入删除，要全部移动位置
- - 添加元素有可能触发，分配额外空间，这里需要进行一次拷贝移动
- list 和 forward_list 作为链表设计，随机访问要遍历，额外内存开销因为是指针形，所以也很大
- deque 结构更为复杂，双端添加删除很快，中间代价可能会很高（高过 vector
- array 是 C++11 的标准，大小固定，更安全，更易用
- forward_list 性能跟手写的单向链表相似，为了追求效率，没有 size 函数来记录大小

如何选择容器？
- vector 或者 list 是最先考虑的
- 根据特殊情况，再换别的

## 概览

容器有一大部分的通用操作和定义，这里选几个我平时不熟悉的来看看

类型别名  | 描述
------------- | ------------- 
iterator | 迭代器
const_iterator  | 常量迭代器，可读不可写
size_type | 无符号整数，足够保存最大可能大小
difference_type | 带符号整数，足够保存两个迭代器之间的距离，可以为负

反向容器成员 | 描述
------------- | ------------- 
reverse_iterator | 按逆序寻址元素的迭代器
const_reverse_iterator | 常量逆迭代器
c.rbegin(), c.rend() | 返回指向 尾部 和 头部 的逆迭代器
c.crbegin(), c.crend() | 上面的常量版本

- 迭代器的范围都是，**左闭合区间**， $[begin, end)$
- forward_list 没有逆向迭代器，也没有 **--** 操作

### 容器的初始化
容器的初始化，我认为应该分5类
- 默认初始化  ```C c;```
- 拷贝初始化 ```C c1(c2)```, ```C c1=c2```
- 花括号初始化 ```C c{a,b,c}```,```C c={a,v,c}```
- 迭代器初始化 ```C c(begin_it, end_it)```
- size大小初始化 ```C c(n)```, ```C c(n, t)```
- array 不支持 大小初始化，花括号初始化也必须数目要小于 array 的大小

### 赋值和swap
常见的赋值运算

代码  | 描述
------------- | ------------- 
```c1=c2``` | c1 中的元素替换为 c2 中元素的拷贝，必须具有相同的类型
```c={a, b, c}``` | c1 中的元素替换为 初始化列表 中元素的拷贝，array 不适用
```swap(c1,c2); c1.swap(c2)``` | 交换 c1 和 c2 中的元素，c1 c2 必须具有相同类型，交换效率比拷贝高
```seq.assgin(b,e)``` | seq 中的元素，替换为迭代器范围中的元素
```seq.assign(il)``` | seq 中的元素，替换为初始化列表 il 中的元素
```seq.assign(n, t)``` |seq 中的元素，替换为 n 个 t
- assign 的所有相关操作，对 array 都不适用
- 所有赋值操作，都是拷贝
- 所有赋值操作，都会使得，**原来的迭代器，指针，引用，失效**
- 尽量使用非成员版本的 swap 函数，符合泛型编程的思想。
- swap交换函数，原来的迭代器，指针，引用，不会失效，但是指向的元素，会在另一个容器中，例外是
	- string：因为string 的swap，会完全失效
	- array：指向的元素，还在原来的容器中，但是，元素的值做了交换

### 容器大小操作

- 自定义的容器，要支持2个容器之间的比较，需要定义 == 和 < 运算

## 顺序容器操作

### 添加

- 主要分两类
	- insert/push：原有接口
	- emplace：C++11 标准，相对更省，推荐使用，[网上分析](https://www.cnblogs.com/narjaja/p/10039509.html)
- 对一个 vector，string，deuqe插入元素，会使**原来的迭代器，指针，引用，失效**
- 关键概念，**容器元素是拷贝**
	- 不管是，对象初始化，对象插入，都是放入的是元素的拷贝，而不是对象本身
	- emplace 就不一样，人家传的是参数，就是直接新建，所以快
- **insert 的返回值**
	- insert 插入的，是在 指向 it 之前插入
	- insert 返回的，是之前的位置
```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v = { 2,4,6,8,10 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if ((*it & 0x1) == 0)
		{
			it = v.insert(it, *it - 1);
			++it;
		}
	}
}
```
- 补全 1-10 的例子

### 访问操作

代码  | 描述
------------- | ------------- 
```c.back()```|返回尾元素的引用
```c.front()```|返回首元素的引用
```c[n];c.at(n)```|返回下标为n的元素引用

- at和下标操作，只适用于 string，vector，deque，array，链表类都不行
- back 不适用于 forward_list
```
if (!c.empty()) {
	c.front() = 42;      // 对第一个元素做赋值
	auto &v = c.back();   // 获得指向最后一个元素的引用
	v = 1024;          // 改变c中的元素
	auto v2 = c.back();   // v2不是一个引用，它是 c.back() 的一个拷贝
	v2 = 0;           // 不能改变c中的元素
}
```
- 访问容器中元素的函数，都是返回引用，(at，下标，front，back)，如果容器是const对象，则返回 const 引用

### 删除
代码  | 描述
------------- | ------------- 
```c.pop_back()```|删除c中的尾元素，返回void
```c.pop_front()```|删除c中的首元素，返回void
```c.erase(p)```|删除迭代器p所指向的元素，返回一个被删除元素之后的迭代器，如果删除的是尾元素，返回尾后（EOF）迭代器
```c.erase(b,e)```|删除 b，e之间的元素，返回 e 后面一个的迭代器
```c.clear()```|删除 c 中的所有元素
- forward_list 有特殊版本的 erase
- forward_list 不支持 pop_back；vector 和 string 不支持 pop_front

### 特殊的 forward_list 操作

因为 forward_list 的特殊性，我们无法知道一个元素它的前一个是什么，所以只能删除它后面的
这里定义了 **首前**元素，这个元素并不存在，但它在 第一个元素之前，目的就是实现对 首元素 的操作

代码  | 描述
------------- | ------------- 
```lst.before_begin()```|返回首前元素，不能解引用
```lst.cbefore_begin()```|const 迭代器版
```lst.insert_after(p,t);lst.insert_after(p,n,t);```|在p之后插入元素，t是对象，n是数量
```lst.insert_after(p,b,e);lst.insert_after(p,il);```|b，e是一个范围，il 是一个花括号列表
``` ```|返回的一个，指向最后一个插入的元素的迭代器。如果范围是空，返回 p
```emplace_after(p,args)```|用 args 创建一个新元素，并插入在 p 后面，返回指向这个新元素的迭代器
```lst.erase_after(p);lst.erase_after(b,e)```|删除 p 指向的位置之后的元素，删除从b之后(不包括b)，直到 e 的元素。返回一个指向被删元素，之后元素的迭代器，如果不存在，返回 尾后迭代器

### 改变容器大小

resize 可以用来增大或缩小容器，注意
- 如果比原来大小小，会丢弃多余的元素
- resize 会使vector，deque，string的引用，迭代器，指针失效。（重新分配

### 导致迭代器失效的操作

#### 添加
- 如果是 vector 或 string，可能会触发存储空间的重新分配，这个时候所有的迭代器，指针，引用都会失效。如果没有触发重新分配，那么失效的是，插入位置之后的内容。
- 对于 deque，插入到除了首尾位置之外的任何位置，都会导致迭代器，指针，引用失效。如果是在首尾位置添加元素，迭代器会失效，但是指针和引用不会失效。
- 对于 list 和 forward_list，不会失效。
### 删除
- 对于 list 和 forward_list，不会失效
- 对于 deque，如果在首尾之外的位置，删除，那么全部失效。如果是尾元素删除，只影响 尾后迭代器。如果是首元素，其他元素不受影响
- 对于 vector 和 string，被删除之前的，依然有效，之后的，失效。

### 示例
- 重新定位迭代器，非常重要
- 不要保存 end 返回的迭代器，因为这个迭代器，太容易失效了

