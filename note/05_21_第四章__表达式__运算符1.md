# 基础

- C++ 定义了 X元运算符的概念
- - 一元运算符：作用于一个运算对象，比如取地址符（&）和解引用符（\*）
- - 二元运算符：作用于两个运算对象，大多数运算符都是二元
- - 三元运算符：应该只有 ?: 运算
- - 函数调用：也是一种特殊的运算符，它的运算对象没有限制

#####

- 重载运算符，以下属性不能修改
- - 运算对象的个数
- - 运算符的优先级
- - 结合律

#####
- **左值** 和 **右值**
- - 当一个对象被用作右值时，用的是对象的值（内容）
- - 当一个对象被用作左值时，用的是对象的身份（在内存中的位置）
- - 需要右值的地方，可以用左值替代，但不能把右值当成左值使用。（移动例外，后面谈）
- - - 赋值运算符，需要：**非常量左值**作为左侧运算对象，得到结果：一个**左值**
- - - 取地址符（&），作用于一个**左值**运算对象，返回一个指向该对象的指针，这个指针是**右值**
- - - 内置解引用符（\*），下标运算符，迭代器解引用符，string和vector的下标运算符，他们的结果都是**左值**，所以有 ```*it=xxx```
- - - 内置类型和迭代器的递增递减运算符，作用于**左值**对象，其前置版本所得的结果是**左值**(好像后置版本得到的也是左值，但返回的应该是原始值的备份，所以没什么作用
- - - decltype 使用也和左值右值有关系
- - - - 左值，会得到一个引用，```decltype(a[1])``` 得到的是一个引用，也就是 ```int&```
- - - - 右值，得到对应的类型

####
- **求值顺序**
```c++
int i = f1() * f2(); // 未定义
```
- 这段代码是未定义的，因为f1和f2的调用先后，位置
```
int i = 0;
cout << i << " " << ++i << endl;
```
- 同理，```<<++i``` 和 ```<< i``` 的顺序无法推断
- 在C++语言中，大多数二元运算符的求值顺序都没有定义，交给了编译器优化
- 复合表达式的写法
- - 最好用括号
- - 如果改变了某个运算对象的值，最好不要在其他地方使用这个运算对象，除非整个子表达式本身就是另一个子表达式的运算对象，比如 ```*++iter``` 是OK的，但是 ```cout << i << " " << ++i << endl``` 不行

# 算术运算符
- 算术运算符的运算对象和求值结果都是**右值**
- ```bool b = -true```，b的值时 true，只有 0 才是 false
- 取模和除法，其符号遵循
- - ```(-m)/n``` 和 ```m/(-n)``` 等于 ```-（m/n）```
- - ```(-m)%n``` 等于 ```-（m%n）```，```m%(-n)``` 等于 ```m%n```
- 算术运算会出现环绕（short +1超出最大范围，会变成最小值）等问题

# 逻辑和关系运算符
- 短路求值，这样是有先后顺序的，所以 ```f1() && f2()```一定是 f1 先执行
- ```val==true``` 这只会在val为 1 的时候，才会是 true

# 赋值运算符
```c++
if  (p = getPtr() != 0)
---
if  (p = (getPtr() != 0)) // 右结合律
```
- - 赋值运算符合右结合律

# 递增或者递减运算符
- 除非必须，不要使用后置版本
- - 前置，+1，并返回
- - 后置，原来的拷贝，+1，返回备份
```c++
cout << *iter++ << endl;
---
cout << *iter << endl;
*iter++
```
- 尽量用上面的写法，更简洁，效率更高
- 大部分的运算符都没有求值顺序，比如：
```
*beg = toupper(*beg++); // 未定义
vec[ival++]  <= vec[ival]; // 未定义
```
- 这里的问题，等号，小于等于号，两边是不同的表达式，赋值号并没有规定应该先算左边还是右边，所以会根据机器不同，结果不同。

# 成员访问运算符
- 箭头运算符，用于一个指针类型的运算对象，结果是一个**左值**
- 点运算符，成员所属的对象是左值，那么结果就是**左值**，若是右值，那么结果就是**右值**

# sizeof运算符
- 返回 size_t 类型，且运算不会实际求运算对象的值


# 类型转换
- static_cast：只要不包含底层const，都可以使用static_cast
- const_cast：只能改变对象的底层const
- reinterpret_cast：提供重新解释，多用于 void* 的解释，ASCI表的映射
```c++
int *ip = new int(65); // *ip: 65
char *pc = reinterpret_cast<char*>(ip); // *pc: A
```